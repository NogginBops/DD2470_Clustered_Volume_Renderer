#version 460 core

// The clusters are AABBs in view space
// so that they are aligned with the view direction.
struct Cluster 
{
    vec4 Min;
    vec4 Max;
};

layout(std430, binding=0) writeonly buffer Clusters
{
    Cluster ssbo_clusters[];
};

layout(std140, row_major, binding=1) uniform ProjectionData
{
    mat4 u_InverseProjectionMatrix;
    uvec3 u_GridSize;
    uvec2 u_ScreenDimentions;
    float u_zNear;
    float u_zFar;
};

vec3 screenToView(vec4 screen)
{
    screen.xy = screen.xy / u_ScreenDimentions;
    screen.xy = screen.xy * 2 - 1;
    vec4 view = screen * u_InverseProjectionMatrix;
    return view.xyz / view.w;
}

vec3 GetViewPos(vec2 uv, float ndcDepth)
{
    vec4 clipCoord = vec4(uv * 2 - 1, ndcDepth, 1.0);
    vec4 viewCoord = clipCoord * u_InverseProjectionMatrix;
    return viewCoord.xyz / viewCoord.w;
}

float GetSliceDepth(float zSlice)
{
    return -u_zNear * pow(u_zFar / u_zNear, zSlice / u_GridSize.z);
}

float ViewDepth2NDC(float zView)
{
    float zRange = u_zFar - u_zNear;
    return -((-(u_zFar + u_zNear) / zRange) * zView + ((-2 * u_zFar * u_zNear) / zRange)) / zView;
}

vec3 GetCellPositionViewSpace(uvec3 gridCoordinate, vec3 cellOffset, out float viewDepth)
{
    vec2 volumeUV = (gridCoordinate.xy + cellOffset.xy) / u_GridSize.xy;
    viewDepth = GetSliceDepth(gridCoordinate.z + cellOffset.z);
    float ndcDepth = ViewDepth2NDC(viewDepth);
    return GetViewPos(volumeUV, ndcDepth);
}

vec3 intersectZPlane(vec3 direction, float zPlane)
{
    // Is it direction.z or -direction.z?
    return (zPlane / direction.z) * direction;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uvec2 tileSizePx = u_ScreenDimentions / gl_NumWorkGroups.xy;
    uint tileIndex = gl_WorkGroupID.x +
                     gl_WorkGroupID.y * gl_NumWorkGroups.x +
                     gl_WorkGroupID.z * (gl_NumWorkGroups.x * gl_NumWorkGroups.y);

    float maxViewDepth = 0;
    //vec3 maxPointView = GetCellPositionViewSpace(gl_WorkGroupID, vec3(1), maxViewDepth);
    //vec3 minPointView = GetCellPositionViewSpace(gl_WorkGroupID, vec3(0), maxViewDepth);

    // Top right
    vec4 maxPointScreen = vec4(vec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y + 1) * tileSizePx, -1.0, 1.0);
    // Bottom left
    vec4 minPointScreen = vec4(gl_WorkGroupID.xy * tileSizePx, -1.0, 1.0);

    vec3 maxPointView = screenToView(maxPointScreen);
    vec3 minPointView = screenToView(minPointScreen);

    //Near and far values of the cluster in view space
    float tileNear  = -u_zNear * pow(u_zFar/ u_zNear, gl_WorkGroupID.z / float(gl_NumWorkGroups.z));
    float tileFar   = -u_zNear * pow(u_zFar/ u_zNear, (gl_WorkGroupID.z + 1) / float(gl_NumWorkGroups.z));

    vec3 minPointNear = intersectZPlane(minPointView, tileNear);
    vec3 minPointFar  = intersectZPlane(minPointView, tileFar);
    vec3 maxPointNear = intersectZPlane(maxPointView, tileNear);
    vec3 maxPointFar  = intersectZPlane(maxPointView, tileFar);

    // Convert the screen space points into
    vec3 minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
    vec3 maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

    ssbo_clusters[tileIndex].Min = vec4(minPointAABB, 1.0);
    ssbo_clusters[tileIndex].Max = vec4(maxPointAABB, 1.0);
}
