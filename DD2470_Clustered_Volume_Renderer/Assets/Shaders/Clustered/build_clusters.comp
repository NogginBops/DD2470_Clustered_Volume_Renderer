#version 460 core

// The clusters are AABBs in view space
// so that they are aligned with the view direction.
struct Cluster 
{
    vec4 Min;
    vec4 Max;
};

layout(std430, binding=0) writeonly buffer Clusters
{
    Cluster ssbo_clusters[];
};

layout(std140, row_major, binding=1) uniform ProjectionData
{
    mat4 u_InverseProjectionMatrix;
    mat4 u_ViewMatrix;
    uvec3 u_GridSize;
    uvec2 u_ScreenDimentions;
    float u_zNear;
    float u_zFar;
};

vec3 screenToView(vec4 screen)
{
    screen.xy = screen.xy / u_ScreenDimentions;
    screen.xy = screen.xy * 2 - 1;
    vec4 view = screen * u_InverseProjectionMatrix;
    return view.xyz / view.w;
}

vec3 GridToView(vec2 grid)
{
    vec2 gridUV = grid.xy / u_GridSize.xy;
    gridUV.xy = gridUV.xy * 2 - 1;
    vec4 view = vec4(gridUV, -1.0, 1.0) * u_InverseProjectionMatrix;
    return view.xyz / view.w;
}

vec3 GetViewPos(vec2 uv, float ndcDepth)
{
    vec4 clipCoord = vec4(uv * 2 - 1, ndcDepth, 1.0);
    vec4 viewCoord = clipCoord * u_InverseProjectionMatrix;
    return viewCoord.xyz / viewCoord.w;
}

float GetSliceDepth(float zSlice)
{
    return -u_zNear * pow(u_zFar / u_zNear, zSlice / u_GridSize.z);
}

float ViewDepth2NDC(float zView)
{
    float zRange = u_zFar - u_zNear;
    return -((-(u_zFar + u_zNear) / zRange) * zView + ((-2 * u_zFar * u_zNear) / zRange)) / zView;
}

vec3 GetCellPositionViewSpace(uvec3 gridCoordinate, vec3 cellOffset, out float viewDepth)
{
    vec2 volumeUV = (gridCoordinate.xy + cellOffset.xy) / u_GridSize.xy;
    viewDepth = GetSliceDepth(gridCoordinate.z + cellOffset.z);
    float ndcDepth = ViewDepth2NDC(viewDepth);
    return GetViewPos(volumeUV, ndcDepth);
}

vec3 IntersectZPlane(vec3 direction, float zPlane)
{
    // Is it direction.z or -direction.z?
    return (zPlane / direction.z) * direction;
}

vec3 lineIntersectionToZPlane(vec3 A, vec3 B, float zDistance){
    //Because this is a Z based normal this is fixed
    vec3 normal = vec3(0.0, 0.0, 1.0);

    vec3 ab =  B - A;

    //Computing the intersection length for the line and the plane
    float t = (zDistance - dot(normal, A)) / dot(normal, ab);

    //Computing the actual xyz position of the point along the line
    vec3 result = A + t * ab;

    return result;
}

layout(local_size_x = 4, local_size_y = 4, local_size_z = 2) in;
void main()
{
    if (any(greaterThanEqual(gl_GlobalInvocationID, u_GridSize)))
        return;

    uint tileIndex = gl_GlobalInvocationID.x +
                     gl_GlobalInvocationID.y * u_GridSize.x +
                     gl_GlobalInvocationID.z * (u_GridSize.x * u_GridSize.y);

    vec2 maxPointGrid = vec2(gl_GlobalInvocationID.xy + uvec2(1, 1));
    vec2 minPointGrid = vec2(gl_GlobalInvocationID.xy);

    vec3 maxPointView = GridToView(maxPointGrid);
    vec3 minPointView = GridToView(minPointGrid);

    //Near and far values of the cluster in view space
    float tileNear  = GetSliceDepth(gl_GlobalInvocationID.z);
    float tileFar   = GetSliceDepth(gl_GlobalInvocationID.z + 1);

    vec3 minPointNear = IntersectZPlane(minPointView, tileNear);
    vec3 minPointFar  = IntersectZPlane(minPointView, tileFar);
    vec3 maxPointNear = IntersectZPlane(maxPointView, tileNear);
    vec3 maxPointFar  = IntersectZPlane(maxPointView, tileFar);

    // Convert the screen space points into
    vec3 minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
    vec3 maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

    ssbo_clusters[tileIndex].Min = vec4(minPointAABB, 1.0);
    ssbo_clusters[tileIndex].Max = vec4(maxPointAABB, 1.0);
}
