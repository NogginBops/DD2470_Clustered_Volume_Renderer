#version 460 core

// FIXME: Make this something else
layout(local_size_x = 16, local_size_y = 9, local_size_z = 4) in;

layout(std140, row_major, binding=1) uniform ProjectionData
{
    mat4 u_InverseProjectionMatrix;
    mat4 u_ViewMatrix;
    uvec3 u_GridSize;
    uvec2 u_ScreenDimentions;
    float u_zNear;
    float u_zFar;
};

// The clusters are AABBs in view space
// so that they are aligned with the view direction.
struct Cluster 
{
    vec4 Min;
    vec4 Max;
};

layout(std430, binding=0) readonly buffer Clusters
{
    Cluster ssbo_clusters[];
};

// FIXME: Define this in a single include type file...
struct PointLight
{
	vec4 PositionAndInvSqrRadius;
	vec4 ColorAndSqrRadius;
};

layout(std430, row_major, binding=1) readonly buffer PointLights
{
	PointLight ssbo_lights[];
};

layout(std430, binding=2) writeonly buffer LightIndex
{
    uint ssbo_lightIndexList[];
};

struct LightGridCell
{
    uint Offset;
    uint Count;
};

layout(std430, binding=3) writeonly buffer LightGrid
{
    LightGridCell ssbo_lightGrid[];
};

struct DebugData
{
    uint cluster;
    uint light;
    vec3 lightViewPos;
    vec3 aabbMin;
    vec3 aabbMax;
    float distance;
    float radius;
};

layout(std430, binding=4) buffer Debug
{
    DebugData ssbo_debugData[];
};

layout(binding = 0) uniform atomic_uint atomic_globalIndexCount;

shared PointLight shared_Lights[gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z];

float squaredDistanceAABB(vec3 position, uint clusterIndex)
{
    float sqrDist = 0.0;
    Cluster cluster = ssbo_clusters[clusterIndex];

    vec3 minDiff = mix(vec3(0), cluster.Min.xyz - position, lessThan(position, cluster.Min.xyz));
    minDiff = minDiff * minDiff;

    vec3 maxDiff = mix(vec3(0), position - cluster.Max.xyz, greaterThan(position, cluster.Max.xyz));
    maxDiff = maxDiff * maxDiff;
    
    vec3 diff = minDiff + maxDiff;

    return diff.x + diff.y + diff.z;
}

bool testSphereAABBB(uint light, uint clusterIndex)
{
    float invSqrRadius = shared_Lights[light].PositionAndInvSqrRadius.w;
    vec3 center = vec3(vec4(shared_Lights[light].PositionAndInvSqrRadius.xyz, 1.0) * u_ViewMatrix);
    float squareDistance = squaredDistanceAABB(center, clusterIndex);
    float invSqrDist = 1 / squareDistance;

    //ssbo_gridLightDistance[clusterIndex * 26 + light] = invSqrDist;
    //ssbo_debugData[clusterIndex * ssbo_lights.length() + light].cluster = clusterIndex;
    //ssbo_debugData[clusterIndex * ssbo_lights.length() + light].light = light;
    //ssbo_debugData[clusterIndex * ssbo_lights.length() + light].lightViewPos = center;
    //ssbo_debugData[clusterIndex * ssbo_lights.length() + light].aabbMin = ssbo_clusters[clusterIndex].Min.xyz;
    //ssbo_debugData[clusterIndex * ssbo_lights.length() + light].aabbMax = ssbo_clusters[clusterIndex].Max.xyz;
    //ssbo_debugData[clusterIndex * ssbo_lights.length() + light].distance = sqrt(squareDistance);
    //ssbo_debugData[clusterIndex * ssbo_lights.length() + light].radius = sqrt(shared_Lights[light].ColorAndSqrRadius.w);

    return invSqrDist >= invSqrRadius;
}

bool testSphereVsAABBB(vec3 sphereCenter, float squareRadius, vec3 aabbMin, vec3 aabbMax)
{
    // FIXME: Calculate the AABB as center + halfSize
    vec3 aabbCenter = (aabbMin + aabbMax) * 0.5;
    vec3 aabbHalfSize = (aabbMax - aabbMin) * 0.5;

    vec3 delta = max(abs(aabbCenter - sphereCenter) - aabbHalfSize, 0);
    float distanceSquare = dot(delta, delta);
    return distanceSquare <= squareRadius;
}

bool testSphereVsAABBB2(vec3 sphereCenter, float squareRadius, vec3 aabbMin, vec3 aabbMax)
{
    vec3 closestPoint = max(min(sphereCenter, aabbMax), aabbMin);
    vec3 diff = closestPoint - sphereCenter;
    float distanceSquare = dot(diff, diff);
    return distanceSquare <= squareRadius;
}

void main()
{
    // This is the wrong way to do this, because different
    // work groups are not synced it's possible for one work group
    // to finish the entire execution before the "first" invocation
    // gets here.
    // One way to do this is to do this "externally" in the opengl api
    // alternatively we could have this happen when we build light clusters.
    //if (gl_GlobalInvocationID == 0)
    //{
    //    atomicCounterExchange(atomic_globalIndexCount, 0);
    //}
    //barrier();

    uint threadCount = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
    uint lightCount  = ssbo_lights.length();
    // ceil(lightCount / threadCount)
    uint numBatches = (lightCount + threadCount - 1) / threadCount;

    uint clusterIndex = gl_LocalInvocationIndex + gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * gl_WorkGroupID.z;

    uint visibleLightCount = 0;
    uint visibleLightIndices[256];

    for(uint batch = 0; batch < numBatches; batch++)
    {
        uint lightIndex = batch * threadCount + gl_LocalInvocationIndex;

        // This means that the last light must always be "null"
        lightIndex = min(lightIndex, lightCount);

        shared_Lights[gl_LocalInvocationIndex] = ssbo_lights[lightIndex];

        // Make sure that all shared_Lights have been written.
        barrier();

        for (uint light = 0; light < threadCount; light++)
        {
            if (batch * threadCount + light >= lightCount)
                break;

            /*if (visibleLightCount < visibleLightIndices.length())
            {
                vec3 lightPosition = shared_Lights[light].PositionAndInvSqrRadius.xyz;
                float squareRadius = shared_Lights[light].ColorAndSqrRadius.w;
                Cluster cluster = ssbo_clusters[clusterIndex];

                if (testSphereVsAABBB2(lightPosition, squareRadius, cluster.Min.xyz, cluster.Max.xyz))
                {
                    visibleLightIndices[visibleLightCount] = batch * threadCount + light;
                    visibleLightCount++;
                }
            }*/

            if (testSphereAABBB(light, clusterIndex) && visibleLightCount < visibleLightIndices.length())
            {
                visibleLightIndices[visibleLightCount] = batch * threadCount + light;
                visibleLightCount++;
            }
            //visibleLightIndices[visibleLightCount] = batch * threadCount + light;
            //visibleLightCount++;
        }
    }

    barrier();

    uint offset = atomicCounterAdd(atomic_globalIndexCount, visibleLightCount);

    for (uint i = 0; i < visibleLightCount; i++)
    {
        ssbo_lightIndexList[offset + i] = visibleLightIndices[i];
    }
    
    ssbo_lightGrid[clusterIndex].Offset = offset;
    ssbo_lightGrid[clusterIndex].Count = visibleLightCount;
}