#line 2 1
//#version 460 core

layout(rgba16f, binding=0) uniform readonly image3D img_VolumeInScatterAndExtinction;

layout(rgba16f, binding=1) uniform writeonly image3D img_VolumeIntegratedInScatteringAndTransmittance;

// #include "common.glsl"

// Defined in common.glsl..
/*layout(std140, row_major, binding=0) uniform ViewData
{
    mat4 u_InverseProjectionMatrix;
    mat4 u_InverseViewMatrix;
    vec3 u_GridSize;
    uvec2 u_ScreenDimentions;
    float u_zNear;
    float u_zFar;
};*/

layout(local_size_x=16, local_size_y=9, local_size_z=1) in;
void main()
{
    vec4 accumScatteringTransmittance = vec4(0.0, 0.0, 0.0, 1.0);

    for (uint depth = 0; depth < u_GridSize.z; depth++)
    {
        ivec3 imageCoord = ivec3(gl_GlobalInvocationID.xy, depth);

        // FIXME: This there a better way to evaluate this?
        // This is backwards because view depth is negative.
        float stepLen = SliceToViewDepth(depth) - SliceToViewDepth(depth + 1);

        vec4 inScatterAndExctinction = imageLoad(img_VolumeInScatterAndExtinction, imageCoord);
        float transmittance = exp(-inScatterAndExctinction.w * stepLen);

        // FIXME: Do this properly?
        vec3 scatteringIntegratedOverSlice = (inScatterAndExctinction.rgb - inScatterAndExctinction.rgb * transmittance) / max(inScatterAndExctinction.w, 0.00001);
        //vec3 scatteringIntegratedOverSlice = inScatterAndExctinction.rgb * (1.0 - transmittance) / min(inScatterAndExctinction.w, 0.00001);

        accumScatteringTransmittance.rgb += scatteringIntegratedOverSlice * accumScatteringTransmittance.a;
        //accumScatteringTransmittance.rgb += inScatterAndExctinction.rgb * accumScatteringTransmittance.a;
        accumScatteringTransmittance.a *= transmittance;

        imageStore(img_VolumeIntegratedInScatteringAndTransmittance, imageCoord, accumScatteringTransmittance);
    }
}