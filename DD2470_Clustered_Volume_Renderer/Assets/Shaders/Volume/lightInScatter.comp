#version 460 core

layout(rgba16f, binding=0) uniform image3D img_VolumeScatterAndExtinction;
layout(rgba16f, binding=1) uniform image3D img_VolumeEmissionAndPhase;

layout(std140, row_major, binding=0) uniform ViewData
{
    mat4 inverseProjectionMatrix;
    mat4 inverseViewMatrix;
    uvec2 screenDimentions;
    float zNear;
    float zFar;
};

layout(location=0) uniform vec3 u_CameraPosition;

struct PointLight
{
	vec4 PositionAndInvSqrRadius;
	vec4 ColorAndSqrRadius;
};

layout(std430, row_major, binding=1) readonly buffer PointLights
{
	PointLight ssbo_lights[];
};

layout(std430, binding=2) writeonly buffer LightIndex
{
    uint ssbo_lightIndexList[];
};

struct LightGridCell
{
    uint Offset;
    uint Count;
};

layout(std430, binding=3) writeonly buffer LightGrid
{
    LightGridCell ssbo_lightGrid[];
};

float SmoothDistanceAttenuation(float squareDistance, float invSquareRadius)
{
	float factor = squareDistance * invSquareRadius;
	float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);
	return smoothFactor * smoothFactor;
}

// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float CalcPointLightAttenuation6(float squareDistance, float invSquareRadius)
{
	float attenuation = 1.0 / max(squareDistance, 0.1*0.1);
	attenuation *= SmoothDistanceAttenuation(squareDistance, invSquareRadius);
	return attenuation;
}

float HenyeyGreenstein(float cosTheta, float g)
{
    float g2 = g * g;
    float numerator = (1 - g2);
    float denom = 1 + g2 - 2*g*cosTheta;
    denom = sqrt(denom * denom * denom);
    return numerator / denom;
}

vec3 intersectZPlane(vec3 direction, float zPlane)
{
    // Is it direction.z or -direction.z?
    return (zPlane / direction.z) * direction;
}

// FIXME: Is this a good local size?
layout(local_size_x=16, local_size_y=9, local_size_z=4) in;
void main()
{
    uvec2 tileSizePx = screenDimentions / (gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    // FIXME: Maybe offset this by 0.5 to center voxels?
    ivec3 imageCoord = ivec3(gl_GlobalInvocationID);
    // Offset coord to center of the froxel
    vec3 screenCoord = vec3(gl_GlobalInvocationID + 0.5);

    float z  = -zNear * pow(zFar/ zNear, screenCoord.z / 96);

    // FIXME: what should the Z coordinate here really be?
    vec3 clipCoord = vec3(vec2(screenCoord.xy * tileSizePx) / screenDimentions, -1);
    clipCoord.xy = clipCoord.xy * 2 - 1;
    vec4 view = vec4(clipCoord, 1.0) * inverseProjectionMatrix;
    view.xyz /= view.w;

    vec3 viewZ = intersectZPlane(view.xyz, z);

    vec3 world = vec3(vec4(viewZ, 1.0) * inverseViewMatrix);

    vec4 scatterAndExctinction = imageLoad(img_VolumeScatterAndExtinction, imageCoord);
    vec4 emissionAndPhase = imageLoad(img_VolumeEmissionAndPhase, imageCoord);

    vec3 inscatter = vec3(0);
    for (uint i = 0; i < ssbo_lights.length(); i++)
    {
        PointLight light = ssbo_lights[i];

        vec3 lightDirection =  light.PositionAndInvSqrRadius.xyz - world.xyz;
        float distanceSquare = dot(lightDirection, lightDirection);
        float attenuation = CalcPointLightAttenuation6(distanceSquare, light.PositionAndInvSqrRadius.w);

        vec3 cameraDirection = normalize(u_CameraPosition - world.xyz);

        // FIXME: Calculate camera direction from world position and camera pos!
        float cosTheta = dot(cameraDirection, normalize(lightDirection));

        float p = HenyeyGreenstein(cosTheta, emissionAndPhase.w);

        // This does not consider the optical depth of the path from this point to the light!!
        vec3 incoming = light.ColorAndSqrRadius.rgb * attenuation;

        // Approximate optical depth to the light.
        incoming *= min(exp(-sqrt(distanceSquare) * 0.015), 1.0);

        inscatter += incoming * p;
    }

    scatterAndExctinction.rgb = inscatter;
    imageStore(img_VolumeScatterAndExtinction, imageCoord, scatterAndExctinction);
}